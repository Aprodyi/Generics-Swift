import UIKit

// MARK: - Задача 1 "Сделать так, чтобы закомментиррованный код работал"

/**
    Все числовые и строковые типы уже реализуют операции сложения и конкатенации.
    Но поскольку мы создаем дженерик, то компилятор на этапе компиляции не знает, может ли он складывать входные типы данных.
    Поэтому мы просто создаем протокол, которому будут соответствовать наши входные типы данных. Но встроенные типы Swift-a уже
    определеняют операции сложения и конкатенации, и нам в протоколе нужно лишь объявить операцию сложения (и можно даже не реализовывать
    данный протокол, поскольку сложение уже определено в числовых и строковых типах).
    И затем в extension-ах мы просто говорим, что наши типы реализуют данный протокол. После уже на этапе компиляции известно, что
    строки и числовые типы поддерживают сложение в дженериках, потому что мы явно говорим дженерику (19 строка), что входные
    типы поддерживают протокол сложения.
*/

protocol Summary {
    static func +(lhs: Self, rhs: Self) -> Self     // Ф-ия принимает в кач-ве операндов свой входной тип данных и возвращает его же
}                                                   // Если бы мы хотели создать дженерик для произвольных типов данных, тогда надо было бы
                                                    // перегружать оператор сложения для каждого конкреного типа, а не просто делать объявление, как тут.

func sumTwoValues<T : Summary>(_ a: T, _ b: T) -> T {
	return a + b
}

extension Int: Summary {}
extension Double: Summary {}
extension Float: Summary {}
extension String: Summary {}

let a = 25.0
let b = 34.0

let resultDouble = sumTwoValues(a, b)
print(resultDouble)

let c = "ABC"
let d = "DEF"

let resultString = sumTwoValues(c, d)
print(resultString)
